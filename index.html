<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survey Evaluator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
            background: white;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(240, 147, 251, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        }

        /* New Channel Filter Buttons */
        .channel-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .channel-filters label {
            margin: 0;
            font-size: 1rem;
            color: #333;
        }

        .channel-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .channel-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .channel-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .output-section {
            margin-top: 30px;
        }

        .table-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .filtered-row {
            display: none !important;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
        }

        /* Survey column styling */
        .survey-yes {
            background-color: #d4edda !important;
            color: #155724;
            font-weight: bold;
        }

        .survey-no {
            background-color: #f8d7da !important;
            color: #721c24;
            font-weight: bold;
        }

        /* Dynamic row styling */
        .dynamic-row {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%) !important;
            border: 2px solid #4facfe !important;
        }

        .dynamic-row td {
            font-weight: 600;
            color: #2c5aa0;
            border-bottom: 2px solid #4facfe;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #e3f2fd;
            transition: background-color 0.2s ease;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Survey Alert Card Styles */
        .survey-alert-card {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 200px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .survey-alert-card.attention {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            animation: pulseAlert 2s infinite;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
        }

        @keyframes pulseAlert {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 107, 107, 0.6);
            }
        }

        .survey-alert-text {
            font-size: 0.95rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .json-output {
            background: #1e1e1e;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            white-space: pre-wrap;
            line-height: 1.4;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .success {
            background: #51cf66;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                padding: 15px;
                margin: 5px 0;
            }
            
            .stats {
                justify-content: center;
            }

            .channel-filters {
                flex-direction: column;
                align-items: stretch;
            }
            .survey-alert-card attention{
                display: block;
            }
            .survey-alert-card{
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Survey Evaluator</h1>
        </div>

        <div class="main-content">
            <div class="input-section">
                <div class="input-group">
                    <label for="textInput">Paste your unstructured text here:</label>
                    <textarea id="textInput" placeholder="Paste your text data here... The converter will automatically detect patterns and structure."></textarea>
                </div>

                <div class="controls">
                    <label for="parseMode">Parsing Mode:</label>
                    <select id="parseMode">
                        <option value="auto">Auto-detect</option>
                        <option value="structured">Structured Data</option>
                        <option value="tabular">Tabular Format</option>
                        <option value="keyvalue">Key-Value Pairs</option>
                        <option value="custom">Custom Delimiters</option>
                    </select>

                    <button class="btn btn-primary" onclick="convertToTable()">Convert to Table</button>
                    <button class="btn btn-secondary" onclick="clearAll()">Clear</button>
                    <button class="btn btn-success" onclick="exportData()">Export JSON</button>
                </div>

                <div class="error" id="errorMessage"></div>
                <div class="success" id="successMessage"></div>
            </div>

            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p>Processing your data...</p>
            </div>

            <div class="output-section" id="outputSection" style="display: none;">
                <div class="stats" id="statsSection"></div>
                
                <!-- New Channel Filter Buttons -->
                <div class="channel-filters" id="channelFilters" style="display: none;">
                    <label>Filter by Channel:</label>
                    <button class="channel-btn" onclick="filterByChannel('voice')" id="voiceBtn">Voice</button>
                    <button class="channel-btn active" onclick="filterByChannel('chat')" id="chatBtn">Chat</button>
                </div>
                
                <div class="table-container" id="tableContainer">
                    <table id="resultTable">
                        <thead id="tableHeader"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>

                <div class="json-output" id="jsonOutput" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        let parsedData = [];
        let tableHeaders = [];
        let activeFilters = {};
        let allData = [];
        let selectedChannel = 'chat'; // Single selection, Chat by default

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 5000);
        }

        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.style.display = 'block';
            setTimeout(() => successEl.style.display = 'none', 3000);
        }

        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
        }

        // Function to get current time in UTC-7 timezone
        function getCurrentUTCMinus7Time() {
            const now = new Date();
            // Convert to UTC-7 (PDT/PST)
            const utcMinus7Time = new Date(now.getTime() - (7 * 60 * 60 * 1000));
            const year = utcMinus7Time.getUTCFullYear();
            const month = String(utcMinus7Time.getUTCMonth() + 1).padStart(2, '0');
            const day = String(utcMinus7Time.getUTCDate()).padStart(2, '0');
            const hours = String(utcMinus7Time.getUTCHours()).padStart(2, '0');
            const minutes = String(utcMinus7Time.getUTCMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        // Function to create dynamic row based on current filters
        function createDynamicRow() {
            // Determine channel based on single selection
            let channel = selectedChannel === 'voice' ? 'Voice' : 'Chat';
            
            // Determine Note Initial based on channel
            let noteInitial = selectedChannel === 'voice' ? '1: Phone In' : '19: Chat';
            
            return {
                'Created': getCurrentUTCMinus7Time(),
                'Agent': 'Current User ILO',
                'Department': 'First Line',
                'Note Initial': noteInitial,
                'Notes': 'null',
                'Channel': channel,
                'Potential Survey': '' // Will be calculated by existing logic
            };
        }

        function parseStructuredText(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            let currentRecord = {};
            let recordStartPattern = /^\d{4}-\d{2}-\d{2}/; // Date pattern

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (!line) continue;

                // Check if this line starts a new record
                if (recordStartPattern.test(line)) {
                    // Save previous record if it exists
                    if (Object.keys(currentRecord).length > 0) {
                        // Add Channel column before saving
                        currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                        records.push({...currentRecord});
                    }
                    
                    // Start new record
                    currentRecord = {};
                    
                    // Parse the date and initial info
                    const parts = line.split(/\s+/);
                    currentRecord.Created = parts[0] + ' ' + parts[1];
                    
                    // Look for agent name in next lines
                    let j = i + 1;
                    while (j < lines.length && !lines[j].match(recordStartPattern) && j < i + 10) {
                        const nextLine = lines[j].trim();
                        
                        if (nextLine && !nextLine.includes(':') && !nextLine.includes('First Line') && 
                            !nextLine.includes('Email sent') && nextLine.length > 2 && nextLine.length < 50) {
                            currentRecord.Agent = nextLine;
                            break;
                        }
                        j++;
                    }
                    
                } else if (line.includes('First Line')) {
                    currentRecord.Department = 'First Line';
                    // Extract location if present
                    const locationMatch = line.match(/^([^,]+),?\s*First Line/);
                    if (locationMatch) {
                        currentRecord.Location = locationMatch[1].trim();
                    }
                    
                } else if (line.includes(':') && line.includes('/')) {
                    // This looks like a title/category line
                    if (!currentRecord['Note Initial']) {
                        currentRecord['Note Initial'] = line;
                    }
                    
                } else if (line.length > 20 && !line.includes('http') && !line.includes('more lines')) {
                    // This looks like a note
                    if (!currentRecord.Notes) {
                        currentRecord.Notes = line;
                    } else {
                        currentRecord.Notes += ' ' + line;
                    }
                }
            }

            // Don't forget the last record
            if (Object.keys(currentRecord).length > 0) {
                currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                records.push(currentRecord);
            }

            return records;
        }

        function determineChannel(noteInitial) {
            if (noteInitial.includes('19: Chat')) {
                return 'Chat';
            } else if (noteInitial.includes('1: Phone In')) {
                return 'Voice';
            } else {
                return 'Other';
            }
        }

        function parseTabularData(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            
            // Try to detect column separators
            const separators = ['\t', '|', ',', ';'];
            let bestSeparator = '\t';
            let maxColumns = 0;
            
            for (const sep of separators) {
                const testLine = lines[0];
                const cols = testLine.split(sep).length;
                if (cols > maxColumns) {
                    maxColumns = cols;
                    bestSeparator = sep;
                }
            }
            
            // Parse headers
            const headers = lines[0].split(bestSeparator).map(h => h.trim()).filter(h => h);
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(bestSeparator).map(v => v.trim());
                if (values.length >= headers.length - 1) {
                    const record = {};
                    headers.forEach((header, index) => {
                        record[header] = values[index] || '';
                    });
                    // Add Channel column
                    record.Channel = determineChannel(record['Note Initial'] || '');
                    records.push(record);
                }
            }
            
            return records;
        }

        function parseKeyValueData(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            let currentRecord = {};
            
            for (const line of lines) {
                if (line.includes(':')) {
                    const colonIndex = line.indexOf(':');
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();
                    
                    if (key && value) {
                        currentRecord[key] = value;
                    }
                } else if (line.trim() === '' || line.includes('---')) {
                    // Empty line or separator - end current record
                    if (Object.keys(currentRecord).length > 0) {
                        // Add Channel column
                        currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                        records.push({...currentRecord});
                        currentRecord = {};
                    }
                }
            }
            
            // Don't forget the last record
            if (Object.keys(currentRecord).length > 0) {
                currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                records.push(currentRecord);
            }
            
            return records;
        }

        function autoDetectFormat(text) {
            const lines = text.trim().split('\n');
            
            // Check for structured format (like the test data)
            const datePattern = /^\d{4}-\d{2}-\d{2}/;
            const hasDatePattern = lines.some(line => datePattern.test(line.trim()));
            
            // Check for tabular format
            const hasTabSeparator = lines.some(line => line.includes('\t'));
            const hasPipeSeparator = lines.some(line => line.includes('|'));
            
            // Check for key-value format
            const hasKeyValue = lines.filter(line => line.includes(':')).length > lines.length * 0.3;
            
            if (hasDatePattern) {
                return 'structured';
            } else if (hasTabSeparator || hasPipeSeparator) {
                return 'tabular';
            } else if (hasKeyValue) {
                return 'keyvalue';
            } else {
                return 'structured'; // Default fallback
            }
        }

        // Function to calculate Potential Survey status separately for each channel
        function calculatePotentialSurveyByChannel(data) {
            // Group data by channel
            const channelGroups = {};
            data.forEach(record => {
                const channel = record.Channel || 'Other';
                if (!channelGroups[channel]) {
                    channelGroups[channel] = [];
                }
                channelGroups[channel].push(record);
            });

            // Process each channel separately
            Object.keys(channelGroups).forEach(channel => {
                // Sort data by Created date (ascending - oldest first) for this channel
                const sortedChannelData = channelGroups[channel].sort((a, b) => {
                    const dateA = new Date(a.Created);
                    const dateB = new Date(b.Created);
                    return dateA - dateB;
                });

                let lastYesDate = null;

                for (let i = 0; i < sortedChannelData.length; i++) {
                    const currentDate = new Date(sortedChannelData[i].Created);
                    
                    if (i === 0) {
                        // First row in each channel is always "Yes"
                        sortedChannelData[i]['Potential Survey'] = 'Yes';
                        lastYesDate = currentDate;
                    } else {
                        // Check if current row is 72 hours (3 days) or more after the last "Yes" in this channel
                        const timeDiff = currentDate - lastYesDate;
                        const hoursDiff = timeDiff / (1000 * 60 * 60); // Convert milliseconds to hours
                        
                        if (hoursDiff >= 72) {
                            sortedChannelData[i]['Potential Survey'] = 'Yes';
                            lastYesDate = currentDate;
                        } else {
                            sortedChannelData[i]['Potential Survey'] = 'No';
                        }
                    }
                }
            });

            // Flatten back to single array
            return data;
        }

        // Function to update survey status for visible rows only (channel-specific)
        function updateSurveyStatusForVisibleRows() {
            const tbody = document.getElementById('tableBody');
            const visibleRows = Array.from(tbody.querySelectorAll('tr:not(.filtered-row)'));
            
            if (visibleRows.length === 0) return;
            
            // Get visible records in the order they appear
            const visibleRecords = visibleRows.map(row => {
                const index = parseInt(row.getAttribute('data-index'));
                const isDynamic = row.classList.contains('dynamic-row');
                return { 
                    record: isDynamic ? createDynamicRow() : allData[index], 
                    rowElement: row, 
                    originalIndex: index,
                    isDynamic: isDynamic
                };
            });
            
            // Group by channel
            const channelGroups = {};
            visibleRecords.forEach(item => {
                const channel = item.record.Channel || 'Other';
                if (!channelGroups[channel]) {
                    channelGroups[channel] = [];
                }
                channelGroups[channel].push(item);
            });

            const surveyColumnIndex = tableHeaders.indexOf('Potential Survey');
            
            // Process each channel separately
            Object.keys(channelGroups).forEach(channel => {
                // Sort by Created date (ascending - oldest first) for this channel
                channelGroups[channel].sort((a, b) => {
                    const dateA = new Date(a.record.Created);
                    const dateB = new Date(b.record.Created);
                    return dateA - dateB;
                });

                let lastYesDate = null;
                
                // Update survey status for this channel's visible records
                for (let i = 0; i < channelGroups[channel].length; i++) {
                    const currentDate = new Date(channelGroups[channel][i].record.Created);
                    let surveyStatus;
                    
                    if (i === 0) {
                        // First visible row in each channel is always "Yes"
                        surveyStatus = 'Yes';
                        lastYesDate = currentDate;
                    } else {
                        // Check if current row is 72 hours or more after the last "Yes" in this channel
                        const timeDiff = currentDate - lastYesDate;
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        
                        if (hoursDiff >= 72) {
                            surveyStatus = 'Yes';
                            lastYesDate = currentDate;
                        } else {
                            surveyStatus = 'No';
                        }
                    }
                    
                    // Update the record if not dynamic (dynamic row updates automatically)
                    if (!channelGroups[channel][i].isDynamic) {
                        allData[channelGroups[channel][i].originalIndex]['Potential Survey'] = surveyStatus;
                    }
                    
                    // Update the cell in the table
                    const cell = channelGroups[channel][i].rowElement.children[surveyColumnIndex];
                    if (cell) {
                        cell.textContent = surveyStatus;
                        cell.className = surveyStatus === 'Yes' ? 'survey-yes' : 'survey-no';
                    }
                }
            });
        }

        function convertToTable() {
            const text = document.getElementById('textInput').value.trim();
            const parseMode = document.getElementById('parseMode').value;
            
            if (!text) {
                showError('Please enter some text to convert');
                return;
            }

            showLoading(true);
            
            setTimeout(() => {
                try {
                    let detectedMode = parseMode;
                    if (parseMode === 'auto') {
                        detectedMode = autoDetectFormat(text);
                    }
                    
                    let data = [];
                    switch (detectedMode) {
                        case 'structured':
                            data = parseStructuredText(text);
                            break;
                        case 'tabular':
                            data = parseTabularData(text);
                            break;
                        case 'keyvalue':
                            data = parseKeyValueData(text);
                            break;
                        default:
                            data = parseStructuredText(text);
                    }
                    
                    if (data.length === 0) {
                        throw new Error('No data could be extracted from the text');
                    }
                    
                    // Calculate Potential Survey status by channel
                    data = calculatePotentialSurveyByChannel(data);
                    
                    parsedData = data;
                    renderTable(data);
                    showSuccess(`Successfully parsed ${data.length} records using ${detectedMode} mode`);
                    
                } catch (error) {
                    showError('Error parsing text: ' + error.message);
                } finally {
                    showLoading(false);
                }
            }, 500);
        }

        function renderTable(data) {
            if (!data || data.length === 0) return;
            
            // Store all data for filtering
            allData = [...data];
            
            // Extract all unique headers and ensure Potential Survey is last
            const headers = [...new Set(data.flatMap(record => Object.keys(record)))];
            
            // Move Potential Survey to the end if it exists
            const surveyIndex = headers.indexOf('Potential Survey');
            if (surveyIndex > -1) {
                headers.splice(surveyIndex, 1);
                headers.push('Potential Survey');
            }
            
            tableHeaders = headers;
            
            // Render simple table header without filter dropdowns
            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = '<tr>' + headers.map(header => 
                `<th>${header}</th>`
            ).join('') + '</tr>';
            
            // Render table body
            renderTableBody(data);
            
            // Set default filters (behind the scenes)
            setDefaultFilters();
            
            // Show channel filter buttons if Channel column exists
            if (headers.includes('Channel')) {
                document.getElementById('channelFilters').style.display = 'flex';
            }
            
            // Show statistics
            renderStats(data, headers);
            
            // Show output section
            document.getElementById('outputSection').style.display = 'block';
            
            // Apply filters and update survey status
            applyAllFilters();
        }

        function renderTableBody(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            data.forEach((record, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-index', index);
                
                tableHeaders.forEach(header => {
                    const cell = document.createElement('td');
                    const value = record[header] || '';
                    
                    // Special styling for Potential Survey column
                    if (header === 'Potential Survey') {
                        cell.textContent = value;
                        cell.className = value === 'Yes' ? 'survey-yes' : 'survey-no';
                    } else {
                        // Format long text for other columns
                        if (value.length > 100) {
                            cell.innerHTML = `<span title="${value}">${value.substring(0, 100)}...</span>`;
                        } else {
                            cell.textContent = value;
                        }
                    }
                    
                    row.appendChild(cell);
                });
                tbody.appendChild(row);
            });
            
            // Add dynamic row at the end
            addDynamicRow();
        }

        function addDynamicRow() {
            const tbody = document.getElementById('tableBody');
            const dynamicRecord = createDynamicRow();
            
            const row = document.createElement('tr');
            row.classList.add('dynamic-row');
            row.setAttribute('data-dynamic', 'true');
            
            tableHeaders.forEach(header => {
                const cell = document.createElement('td');
                const value = dynamicRecord[header] || '';
                
                // Special styling for Potential Survey column
                if (header === 'Potential Survey') {
                    // Survey status will be calculated by updateSurveyStatusForVisibleRows
                    cell.textContent = '';
                    cell.className = '';
                } else {
                    cell.textContent = value;
                }
                
                row.appendChild(cell);
            });
            
            tbody.appendChild(row);
        }

        function setDefaultFilters() {
            // Filter Department to only "First Line"
            if (tableHeaders.includes('Department')) {
                activeFilters['Department'] = ['First Line'];
            }
            
            // Set single channel filter based on selection
            if (tableHeaders.includes('Channel')) {
                const channelToShow = selectedChannel === 'voice' ? 'Voice' : 'Chat';
                activeFilters['Channel'] = [channelToShow];
            }
        }

        function filterByChannel(channel) {
            const voiceBtn = document.getElementById('voiceBtn');
            const chatBtn = document.getElementById('chatBtn');
            
            // Update selected channel (single selection)
            selectedChannel = channel;
            
            // Update button states - only one can be active
            if (channel === 'voice') {
                voiceBtn.classList.add('active');
                chatBtn.classList.remove('active');
            } else if (channel === 'chat') {
                chatBtn.classList.add('active');
                voiceBtn.classList.remove('active');
            }
            
            // Update the channel filter based on selection
            const channelToShow = selectedChannel === 'voice' ? 'Voice' : 'Chat';
            activeFilters['Channel'] = [channelToShow];
            
            // Update dynamic row based on new selection
            updateDynamicRow();
            
            applyAllFilters();
        }

        function updateDynamicRow() {
            const tbody = document.getElementById('tableBody');
            const dynamicRow = tbody.querySelector('.dynamic-row');
            
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                
                tableHeaders.forEach((header, index) => {
                    const cell = dynamicRow.children[index];
                    if (cell && header !== 'Potential Survey') {
                        cell.textContent = dynamicRecord[header] || '';
                    }
                });
            }
        }

        function applyAllFilters() {
            const tbody = document.getElementById('tableBody');
            const rows = tbody.querySelectorAll('tr:not(.dynamic-row)');
            
            let visibleCount = 0;
            
            rows.forEach(row => {
                const rowIndex = parseInt(row.getAttribute('data-index'));
                const record = allData[rowIndex];
                let shouldShow = true;
                
                // Check each active filter
                for (const [header, filterValues] of Object.entries(activeFilters)) {
                    if (filterValues.length === 0) {
                        shouldShow = false;
                        break;
                        continue;
                    }
                    
                    const cellValue = record[header] || '';
                    
                    // Special handling for "Note Initial" containing "19: Chat"
                    if (header === 'Note Initial') {
                        const matchesFilter = filterValues.some(filterValue => 
                            cellValue.includes(filterValue) || filterValue.includes(cellValue)
                        );
                        if (!matchesFilter) {
                            shouldShow = false;
                            break;
                        }
                    } else {
                        // Exact match for other fields
                        if (!filterValues.includes(cellValue)) {
                            shouldShow = false;
                            break;
                        }
                    }
                }
                
                if (shouldShow) {
                    row.classList.remove('filtered-row');
                    visibleCount++;
                } else {
                    row.classList.add('filtered-row');
                }
            });
            
            // Handle dynamic row visibility
            const dynamicRow = tbody.querySelector('.dynamic-row');
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                let shouldShowDynamic = true;
                
                // Check if dynamic row passes filters
                for (const [header, filterValues] of Object.entries(activeFilters)) {
                    if (filterValues.length === 0) {
                        shouldShowDynamic = false;
                        break;
                        continue;
                    }
                    
                    const cellValue = dynamicRecord[header] || '';
                    
                    if (header === 'Note Initial') {
                        const matchesFilter = filterValues.some(filterValue => 
                            cellValue.includes(filterValue) || filterValue.includes(cellValue)
                        );
                        if (!matchesFilter) {
                            shouldShowDynamic = false;
                            break;
                        }
                    } else {
                        if (!filterValues.includes(cellValue)) {
                            shouldShowDynamic = false;
                            break;
                        }
                    }
                }
                
                if (shouldShowDynamic) {
                    dynamicRow.classList.remove('filtered-row');
                    visibleCount++; // Count dynamic row
                } else {
                    dynamicRow.classList.add('filtered-row');
                }
            }
            
            // Update survey status for visible rows after filtering
            updateSurveyStatusForVisibleRows();
            
            // Update statistics
            updateFilteredStats(visibleCount);
        }

        function updateFilteredStats(visibleCount) {
            const statsSection = document.getElementById('statsSection');
            const totalRecords = allData.length;
            const isFiltered = visibleCount !== totalRecords + 1; // +1 for dynamic row
            
            // Count active filters
            const activeFilterCount = Object.keys(activeFilters).filter(key => 
                activeFilters[key] && activeFilters[key].length > 0
            ).length;
            
            // Count "Yes" surveys in visible rows and get last row survey status
            const tbody = document.getElementById('tableBody');
            const visibleRows = tbody.querySelectorAll('tr:not(.filtered-row)');
            const surveyColumnIndex = tableHeaders.indexOf('Potential Survey');
            let yesCount = 0;
            let lastRowSurveyStatus = 'No';
            
            if (surveyColumnIndex !== -1) {
                visibleRows.forEach(row => {
                    const surveyCell = row.children[surveyColumnIndex];
                    if (surveyCell && surveyCell.textContent === 'Yes') {
                        yesCount++;
                    }
                });
                
                // Get last visible row survey status
                if (visibleRows.length > 0) {
                    const lastRow = visibleRows[visibleRows.length - 1];
                    const lastSurveyCell = lastRow.children[surveyColumnIndex];
                    if (lastSurveyCell) {
                        lastRowSurveyStatus = lastSurveyCell.textContent;
                    }
                }
            }
            
            const displayCount = visibleCount > 0 ? visibleCount - 1 : 0; // Subtract dynamic row for display
            
            // Create survey alert card based on last row status
            const surveyAlertCard = lastRowSurveyStatus === 'Yes' 
                ? `<div class="survey-alert-card attention">
                     <div class="survey-alert-text">⚠️ Attention!! - Survey will be generated</div>
                   </div>`
                : `<div class="survey-alert-card">
                     <div class="survey-alert-text">✅ No Survey will be generated</div>
                   </div>`;
            
            const statsHtml = `
                <div class="stat-card">
                    <span class="stat-number">${displayCount}${isFiltered ? `/${totalRecords}` : ''}</span>
                    <span class="stat-label">${isFiltered ? 'Filtered/Total' : 'Records'}</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${tableHeaders.length}</span>
                    <span class="stat-label">Columns</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${activeFilterCount}</span>
                    <span class="stat-label">Active Filters</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${yesCount}</span>
                    <span class="stat-label">Survey Eligible</span>
                </div>
                ${surveyAlertCard}
            `;
            statsSection.innerHTML = statsHtml;
        }

        function renderStats(data, headers) {
            const statsHtml = `
                <div class="stat-card">
                    <span class="stat-number">${data.length}</span>
                    <span class="stat-label">Records</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${headers.length}</span>
                    <span class="stat-label">Columns</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${Math.round(data.reduce((sum, record) => sum + Object.values(record).join(' ').length, 0) / data.length)}</span>
                    <span class="stat-label">Avg Length</span>
                </div>
            `;
            document.getElementById('statsSection').innerHTML = statsHtml;
        }

        function exportData() {
            if (parsedData.length === 0) {
                showError('No data to export. Please convert some text first.');
                return;
            }
            
            // Get currently visible data for export (excluding dynamic row)
            const tbody = document.getElementById('tableBody');
            const visibleRows = tbody.querySelectorAll('tr:not(.filtered-row):not(.dynamic-row)');
            const filteredData = Array.from(visibleRows).map(row => {
                const index = parseInt(row.getAttribute('data-index'));
                return allData[index];
            });
            
            // Add dynamic row data if it's visible
            const dynamicRow = tbody.querySelector('.dynamic-row:not(.filtered-row)');
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                // Update survey status for dynamic row
                const surveyColumnIndex = tableHeaders.indexOf('Potential Survey');
                if (surveyColumnIndex !== -1) {
                    const surveyCell = dynamicRow.children[surveyColumnIndex];
                    if (surveyCell) {
                        dynamicRecord['Potential Survey'] = surveyCell.textContent;
                    }
                }
                filteredData.push(dynamicRecord);
            }
            
            const jsonOutput = document.getElementById('jsonOutput');
            const formattedJson = JSON.stringify(filteredData, null, 2);
            jsonOutput.textContent = formattedJson;
            jsonOutput.style.display = 'block';
            
            // Also create downloadable file
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'converted-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showSuccess(`Data exported successfully! (${filteredData.length} records)`);
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('outputSection').style.display = 'none';
            document.getElementById('jsonOutput').style.display = 'none';
            document.getElementById('channelFilters').style.display = 'none';
            parsedData = [];
            tableHeaders = [];
            activeFilters = {};
            allData = [];
            selectedChannel = 'chat'; // Reset to default
            
            // Reset channel filter buttons to default (Chat selected)
            document.getElementById('voiceBtn').classList.remove('active');
            document.getElementById('chatBtn').classList.add('active');
        }

        // Load sample data for testing
        window.onload = function() {
            const sampleText = `2025-09-08 14:13

Van Khang Vu

CNX Vietnam
First Line
19: Chat / 43: No response
1. Customer not reached / 1: Chat disconnected

Customer contact name: Philip Lledo Genesys ID: https://apps.mypurecloud.de/directory/#/engage/admin/interactions/99fbb787-c5de-4a4b-839d-bb8f8c5f8e16

2025-09-08 13:48

Vuong Hong Ngoc Pham

CNX Vietnam
First Line
1: Phone In / 7: Baggage
2: Baggage claim / 1: Ask customer to send a claim

Customer contact name: Philip Lledo Genesys ID: https://apps.mypurecloud.de/directory/#/engage/admin/interactions/a1a0b3fb-af39-4a50-ad6b-16d5f452057c

2025-09-08 12:55

Shaheen Lakdawala

Mumbai
First Line
32: FL Baggage/Seat Claim / 7: Baggage
5: Receipt reviewed / 1. No error/No refund

Additional information: ******Working on baggage /Seating Claim *****

2025-09-05 07:19

Parag Thombare

Pune
First Line
17: Frontend finalized / 7: Baggage
2: Baggage claim / 1: Ask customer to send a claim

Removed from queue - As per previous notes pax informed they were offered 2PC checked baggage for the OB.`;
            
            document.getElementById('textInput').value = sampleText;
        };
    </script>
</body>
</html>
