<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survey Evaluator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 15px 20px;
            display: flex;
            align-content: center;
            color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            justify-content: center;
        }
        .survey-status {
            display: flex;
            align-items: center;
            align-self: center;
        }

        .survey-alert-card {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 900;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
        }

        .survey-alert-card.attention {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            animation: blinkAlert 1.5s infinite;
        }

        @keyframes blinkAlert {
            0%, 100% { 
                background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            }
            50% { 
                background: linear-gradient(135deg, #ffd93d 0%, #ff9800 100%);
            }
        }

        .survey-alert-text {
            font-size: 2.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .main-content {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        .input-column {
            width: 50%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e1e5e9;
        }

        .output-column {
            width: 50%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 1rem;
        }

        textarea {
            width: 100%;
            flex: 1;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        textarea:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
            background: white;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }

        .channel-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
        }

        .channel-filters label {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        .channel-btn {
            padding: 6px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #667eea;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .channel-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .channel-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.2);
        }

        .output-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .table-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .table-wrapper {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 6px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 10px;
        }

        td {
            padding: 6px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
            font-size: 10px;
        }

        .filtered-row {
            display: none !important;
        }

        .survey-yes {
            background-color: #d4edda !important;
            color: #155724;
            font-weight: bold;
        }

        .survey-no {
            background-color: #f8d7da !important;
            color: #721c24;
            font-weight: bold;
        }

        .dynamic-row {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%) !important;
            border: 2px solid #4facfe !important;
        }

        .dynamic-row td {
            font-weight: 600;
            color: #2c5aa0;
            border-bottom: 2px solid #4facfe;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #e3f2fd;
            transition: background-color 0.2s ease;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            z-index: 1000;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error, .success {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
            display: none;
        }

        .error {
            background: #ff6b6b;
            color: white;
        }

        .success {
            background: #51cf66;
            color: white;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            text-align: center;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .empty-state p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .input-column, .output-column {
                width: 100%;
                border: none;
            }
            
            .input-column {
                height: 50vh;
            }
            
            .output-column {
                height: 50vh;
            }
            
            .header {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }
            
            .survey-status {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="survey-status">
                <div class="survey-alert-card" id="surveyAlert">
                    <div class="survey-alert-text" id="surveyAlertText">Enter data to see survey status</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="input-column">
                <div class="input-section">
                    <div class="input-group">
                        <label for="textInput">Paste your unstructured text here:</label>
                        <textarea id="textInput" placeholder="Paste your text data here... The converter will automatically detect patterns and structure."></textarea>
                    </div>

                    <div class="controls">
                        <label for="parseMode" style="display: none;">Mode:</label>
                        <select id="parseMode" style="display: none;">
                            <option value="auto">Auto-detect</option>
                            <option value="structured">Structured Data</option>
                            <option value="tabular">Tabular Format</option>
                            <option value="keyvalue">Key-Value Pairs</option>
                        </select>

                        <button class="btn btn-primary" onclick="convertToTable()">Convert</button>
                        <button class="btn btn-secondary" onclick="clearAll()">Clear</button>
                        <button class="btn btn-success" style="display: none;" onclick="exportData()">Export</button>
                    </div>

                    <div class="error" id="errorMessage"></div>
                    <div class="success" id="successMessage"></div>
                </div>
            </div>

            <div class="output-column">
                <div class="output-section" id="outputSection">
                    <div class="empty-state" id="emptyState">
                        <h3>No Data Yet</h3>
                        <p>Enter text data and click "Convert" to see results</p>
                    </div>
                    
                    <div class="channel-filters" id="channelFilters" style="display: none;">
                        <label>Channel:</label>
                        <button class="channel-btn" onclick="filterByChannel('voice')" id="voiceBtn">Voice</button>
                        <button class="channel-btn active" onclick="filterByChannel('chat')" id="chatBtn">Chat</button>
                    </div>
                    
                    <div class="table-container" id="tableContainer" style="display: none;">
                        <div class="table-wrapper">
                            <table id="resultTable">
                                <thead id="tableHeader"></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <p>Processing your data...</p>
        </div>
    </div>

    <script>
        let parsedData = [];
        let tableHeaders = [];
        let activeFilters = {};
        let allData = [];
        let selectedChannel = 'chat';

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 5000);
        }

        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.style.display = 'block';
            setTimeout(() => successEl.style.display = 'none', 3000);
        }

        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'flex' : 'none';
        }

        function updateSurveyAlert(status, hasData = false) {
            const alertCard = document.getElementById('surveyAlert');
            const alertText = document.getElementById('surveyAlertText');
            
            if (!hasData) {
                alertCard.className = 'survey-alert-card';
                alertText.textContent = 'Enter data to see survey status';
            } else if (status === 'Yes') {
                alertCard.className = 'survey-alert-card attention';
                alertText.textContent = '⚠️ Attention!! - Survey will be generated';
            } else {
                alertCard.className = 'survey-alert-card';
                alertText.textContent = '✅ No Survey will be generated';
            }
        }

        function getCurrentUTCMinus7Time() {
            const now = new Date();
            const utcMinus7Time = new Date(now.getTime() + (2 * 60 * 60 * 1000));
            const year = utcMinus7Time.getUTCFullYear();
            const month = String(utcMinus7Time.getUTCMonth() + 1).padStart(2, '0');
            const day = String(utcMinus7Time.getUTCDate()).padStart(2, '0');
            const hours = String(utcMinus7Time.getUTCHours()).padStart(2, '0');
            const minutes = String(utcMinus7Time.getUTCMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function createDynamicRow() {
            let channel = selectedChannel === 'voice' ? 'Voice' : 'Chat';
            let noteInitial = selectedChannel === 'voice' ? '1: Phone In' : '19: Chat';
            
            return {
                'Created': getCurrentUTCMinus7Time(),
                'Agent': 'Current User ILO',
                'Department': 'First Line',
                'Note Initial': noteInitial,
                'Notes': 'null',
                'Channel': channel,
                'Potential Survey': ''
            };
        }

        function parseStructuredText(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            let currentRecord = {};
            let recordStartPattern = /^\d{4}-\d{2}-\d{2}/;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (!line) continue;

                if (recordStartPattern.test(line)) {
                    if (Object.keys(currentRecord).length > 0) {
                        currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                        records.push({...currentRecord});
                    }
                    
                    currentRecord = {};
                    const parts = line.split(/\s+/);
                    currentRecord.Created = parts[0] + ' ' + parts[1];
                    
                    let j = i + 1;
                    while (j < lines.length && !lines[j].match(recordStartPattern) && j < i + 10) {
                        const nextLine = lines[j].trim();
                        
                        if (nextLine && !nextLine.includes(':') && !nextLine.includes('First Line') && 
                            !nextLine.includes('Email sent') && nextLine.length > 2 && nextLine.length < 50) {
                            currentRecord.Agent = nextLine;
                            break;
                        }
                        j++;
                    }
                    
                } else if (line.includes('First Line')) {
                    currentRecord.Department = 'First Line';
                    const locationMatch = line.match(/^([^,]+),?\s*First Line/);
                    if (locationMatch) {
                        currentRecord.Location = locationMatch[1].trim();
                    }
                    
                } else if (line.includes(':') && line.includes('/')) {
                    if (!currentRecord['Note Initial']) {
                        currentRecord['Note Initial'] = line;
                    }
                    
                } else if (line.length > 20 && !line.includes('http') && !line.includes('more lines')) {
                    if (!currentRecord.Notes) {
                        currentRecord.Notes = line;
                    } else {
                        currentRecord.Notes += ' ' + line;
                    }
                }
            }

            if (Object.keys(currentRecord).length > 0) {
                currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                records.push(currentRecord);
            }

            return records;
        }

        function parseTabularData(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            
            const separators = ['\t', '|', ',', ';'];
            let bestSeparator = '\t';
            let maxColumns = 0;
            
            for (const sep of separators) {
                const testLine = lines[0];
                const cols = testLine.split(sep).length;
                if (cols > maxColumns) {
                    maxColumns = cols;
                    bestSeparator = sep;
                }
            }
            
            const headers = lines[0].split(bestSeparator).map(h => h.trim()).filter(h => h);
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(bestSeparator).map(v => v.trim());
                if (values.length >= headers.length - 1) {
                    const record = {};
                    headers.forEach((header, index) => {
                        record[header] = values[index] || '';
                    });
                    record.Channel = determineChannel(record['Note Initial'] || '');
                    records.push(record);
                }
            }
            
            return records;
        }

        function parseKeyValueData(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const records = [];
            let currentRecord = {};
            
            for (const line of lines) {
                if (line.includes(':')) {
                    const colonIndex = line.indexOf(':');
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();
                    
                    if (key && value) {
                        currentRecord[key] = value;
                    }
                } else if (line.trim() === '' || line.includes('---')) {
                    if (Object.keys(currentRecord).length > 0) {
                        currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                        records.push({...currentRecord});
                        currentRecord = {};
                    }
                }
            }
            
            if (Object.keys(currentRecord).length > 0) {
                currentRecord.Channel = determineChannel(currentRecord['Note Initial'] || '');
                records.push(currentRecord);
            }
            
            return records;
        }

        function determineChannel(noteInitial) {
            if (noteInitial.includes('19: Chat')) {
                return 'Chat';
            } else if (noteInitial.includes('1: Phone In')) {
                return 'Voice';
            } else {
                return 'Other';
            }
        }

        function autoDetectFormat(text) {
            const lines = text.trim().split('\n');
            const datePattern = /^\d{4}-\d{2}-\d{2}/;
            const hasDatePattern = lines.some(line => datePattern.test(line.trim()));
            const hasTabSeparator = lines.some(line => line.includes('\t'));
            const hasPipeSeparator = lines.some(line => line.includes('|'));
            const hasKeyValue = lines.filter(line => line.includes(':')).length > lines.length * 0.3;
            
            if (hasDatePattern) {
                return 'structured';
            } else if (hasTabSeparator || hasPipeSeparator) {
                return 'tabular';
            } else if (hasKeyValue) {
                return 'keyvalue';
            } else {
                return 'structured';
            }
        }

        function calculatePotentialSurveyByChannel(data) {
            const channelGroups = {};
            data.forEach(record => {
                const channel = record.Channel || 'Other';
                if (!channelGroups[channel]) {
                    channelGroups[channel] = [];
                }
                channelGroups[channel].push(record);
            });

            Object.keys(channelGroups).forEach(channel => {
                const sortedChannelData = channelGroups[channel].sort((a, b) => {
                    const dateA = new Date(a.Created);
                    const dateB = new Date(b.Created);
                    return dateA - dateB;
                });

                let lastYesDate = null;

                for (let i = 0; i < sortedChannelData.length; i++) {
                    const currentDate = new Date(sortedChannelData[i].Created);
                    
                    if (i === 0) {
                        sortedChannelData[i]['Potential Survey'] = 'Yes';
                        lastYesDate = currentDate;
                    } else {
                        const timeDiff = currentDate - lastYesDate;
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        
                        if (hoursDiff >= 72) {
                            sortedChannelData[i]['Potential Survey'] = 'Yes';
                            lastYesDate = currentDate;
                        } else {
                            sortedChannelData[i]['Potential Survey'] = 'No';
                        }
                    }
                }
            });

            return data;
        }

        function updateSurveyStatusForVisibleRows() {
            const tbody = document.getElementById('tableBody');
            const visibleRows = Array.from(tbody.querySelectorAll('tr:not(.filtered-row)'));
            
            if (visibleRows.length === 0) {
                updateSurveyAlert('No', true);
                return;
            }
            
            const visibleRecords = visibleRows.map(row => {
                const index = parseInt(row.getAttribute('data-index'));
                const isDynamic = row.classList.contains('dynamic-row');
                return { 
                    record: isDynamic ? createDynamicRow() : allData[index], 
                    rowElement: row, 
                    originalIndex: index,
                    isDynamic: isDynamic
                };
            });
            
            const channelGroups = {};
            visibleRecords.forEach(item => {
                const channel = item.record.Channel || 'Other';
                if (!channelGroups[channel]) {
                    channelGroups[channel] = [];
                }
                channelGroups[channel].push(item);
            });

            const surveyColumnIndex = tableHeaders.indexOf('Potential Survey');
            let lastRowSurveyStatus = 'No';
            
            Object.keys(channelGroups).forEach(channel => {
                channelGroups[channel].sort((a, b) => {
                    const dateA = new Date(a.record.Created);
                    const dateB = new Date(b.record.Created);
                    return dateA - dateB;
                });

                let lastYesDate = null;
                
                for (let i = 0; i < channelGroups[channel].length; i++) {
                    const currentDate = new Date(channelGroups[channel][i].record.Created);
                    let surveyStatus;
                    
                    if (i === 0) {
                        surveyStatus = 'Yes';
                        lastYesDate = currentDate;
                    } else {
                        const timeDiff = currentDate - lastYesDate;
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        
                        if (hoursDiff >= 72) {
                            surveyStatus = 'Yes';
                            lastYesDate = currentDate;
                        } else {
                            surveyStatus = 'No';
                        }
                    }
                    
                    if (!channelGroups[channel][i].isDynamic) {
                        allData[channelGroups[channel][i].originalIndex]['Potential Survey'] = surveyStatus;
                    }
                    
                    const cell = channelGroups[channel][i].rowElement.children[surveyColumnIndex];
                    if (cell) {
                        cell.textContent = surveyStatus;
                        cell.className = surveyStatus === 'Yes' ? 'survey-yes' : 'survey-no';
                    }
                    
                    // Update last row survey status for the last visible row
                    if (i === channelGroups[channel].length - 1) {
                        lastRowSurveyStatus = surveyStatus;
                    }
                }
            });
            
            updateSurveyAlert(lastRowSurveyStatus, true);
        }

        function convertToTable() {
            const text = document.getElementById('textInput').value.trim();
            const parseMode = document.getElementById('parseMode').value;
            
            if (!text) {
                showError('Please enter some text to convert');
                updateSurveyAlert('No', false);
                return;
            }

            showLoading(true);
            
            setTimeout(() => {
                try {
                    let detectedMode = parseMode;
                    if (parseMode === 'auto') {
                        detectedMode = autoDetectFormat(text);
                    }
                    
                    let data = [];
                    switch (detectedMode) {
                        case 'structured':
                            data = parseStructuredText(text);
                            break;
                        case 'tabular':
                            data = parseTabularData(text);
                            break;
                        case 'keyvalue':
                            data = parseKeyValueData(text);
                            break;
                        default:
                            data = parseStructuredText(text);
                    }
                    
                    if (data.length === 0) {
                        throw new Error('No data could be extracted from the text');
                    }
                    
                    data = calculatePotentialSurveyByChannel(data);
                    parsedData = data;
                    renderTable(data);
                    showSuccess(`Successfully parsed ${data.length} records using ${detectedMode} mode`);
                    
                } catch (error) {
                    showError('Error parsing text: ' + error.message);
                    updateSurveyAlert('No', false);
                } finally {
                    showLoading(false);
                }
            }, 500);
        }

        function renderTable(data) {
            if (!data || data.length === 0) return;
            
            allData = [...data];
            const headers = [...new Set(data.flatMap(record => Object.keys(record)))];
            
            const surveyIndex = headers.indexOf('Potential Survey');
            if (surveyIndex > -1) {
                headers.splice(surveyIndex, 1);
                                    headers.push('Potential Survey');
            }
            
            tableHeaders = headers;
            
            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = '<tr>' + headers.map(header => 
                `<th>${header}</th>`
            ).join('') + '</tr>';
            
            renderTableBody(data);
            setDefaultFilters();
            
            if (headers.includes('Channel')) {
                document.getElementById('channelFilters').style.display = 'flex';
            }
            
            // Hide empty state and show table
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('tableContainer').style.display = 'flex';
            
            applyAllFilters();
        }

        function renderTableBody(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            data.forEach((record, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-index', index);
                
                tableHeaders.forEach(header => {
                    const cell = document.createElement('td');
                    const value = record[header] || '';
                    
                    if (header === 'Potential Survey') {
                        cell.textContent = value;
                        cell.className = value === 'Yes' ? 'survey-yes' : 'survey-no';
                    } else {
                        if (value.length > 50) {
                            cell.innerHTML = `<span title="${value}">${value.substring(0, 50)}...</span>`;
                        } else {
                            cell.textContent = value;
                        }
                    }
                    
                    row.appendChild(cell);
                });
                tbody.appendChild(row);
            });
            
            addDynamicRow();
        }

        function addDynamicRow() {
            const tbody = document.getElementById('tableBody');
            const dynamicRecord = createDynamicRow();
            
            const row = document.createElement('tr');
            row.classList.add('dynamic-row');
            row.setAttribute('data-dynamic', 'true');
            
            tableHeaders.forEach(header => {
                const cell = document.createElement('td');
                const value = dynamicRecord[header] || '';
                
                if (header === 'Potential Survey') {
                    cell.textContent = '';
                    cell.className = '';
                } else {
                    cell.textContent = value;
                }
                
                row.appendChild(cell);
            });
            
            tbody.appendChild(row);
        }

        function setDefaultFilters() {
            if (tableHeaders.includes('Department')) {
                activeFilters['Department'] = ['First Line'];
            }
            
            if (tableHeaders.includes('Channel')) {
                const channelToShow = selectedChannel === 'voice' ? 'Voice' : 'Chat';
                activeFilters['Channel'] = [channelToShow];
            }
        }

        function filterByChannel(channel) {
            const voiceBtn = document.getElementById('voiceBtn');
            const chatBtn = document.getElementById('chatBtn');
            
            selectedChannel = channel;
            
            if (channel === 'voice') {
                voiceBtn.classList.add('active');
                chatBtn.classList.remove('active');
            } else if (channel === 'chat') {
                chatBtn.classList.add('active');
                voiceBtn.classList.remove('active');
            }
            
            const channelToShow = selectedChannel === 'voice' ? 'Voice' : 'Chat';
            activeFilters['Channel'] = [channelToShow];
            
            updateDynamicRow();
            applyAllFilters();
        }

        function updateDynamicRow() {
            const tbody = document.getElementById('tableBody');
            const dynamicRow = tbody.querySelector('.dynamic-row');
            
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                
                tableHeaders.forEach((header, index) => {
                    const cell = dynamicRow.children[index];
                    if (cell && header !== 'Potential Survey') {
                        cell.textContent = dynamicRecord[header] || '';
                    }
                });
            }
        }

        function applyAllFilters() {
            const tbody = document.getElementById('tableBody');
            const rows = tbody.querySelectorAll('tr:not(.dynamic-row)');
            
            let visibleCount = 0;
            
            rows.forEach(row => {
                const rowIndex = parseInt(row.getAttribute('data-index'));
                const record = allData[rowIndex];
                let shouldShow = true;
                
                for (const [header, filterValues] of Object.entries(activeFilters)) {
                    if (filterValues.length === 0) {
                        shouldShow = false;
                        break;
                    }
                    
                    const cellValue = record[header] || '';
                    
                    if (header === 'Note Initial') {
                        const matchesFilter = filterValues.some(filterValue => 
                            cellValue.includes(filterValue) || filterValue.includes(cellValue)
                        );
                        if (!matchesFilter) {
                            shouldShow = false;
                            break;
                        }
                    } else {
                        if (!filterValues.includes(cellValue)) {
                            shouldShow = false;
                            break;
                        }
                    }
                }
                
                if (shouldShow) {
                    row.classList.remove('filtered-row');
                    visibleCount++;
                } else {
                    row.classList.add('filtered-row');
                }
            });
            
            const dynamicRow = tbody.querySelector('.dynamic-row');
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                let shouldShowDynamic = true;
                
                for (const [header, filterValues] of Object.entries(activeFilters)) {
                    if (filterValues.length === 0) {
                        shouldShowDynamic = false;
                        break;
                    }
                    
                    const cellValue = dynamicRecord[header] || '';
                    
                    if (header === 'Note Initial') {
                        const matchesFilter = filterValues.some(filterValue => 
                            cellValue.includes(filterValue) || filterValue.includes(cellValue)
                        );
                        if (!matchesFilter) {
                            shouldShowDynamic = false;
                            break;
                        }
                    } else {
                        if (!filterValues.includes(cellValue)) {
                            shouldShowDynamic = false;
                            break;
                        }
                    }
                }
                
                if (shouldShowDynamic) {
                    dynamicRow.classList.remove('filtered-row');
                } else {
                    dynamicRow.classList.add('filtered-row');
                }
            }
            
            updateSurveyStatusForVisibleRows();
        }

        function exportData() {
            if (parsedData.length === 0) {
                showError('No data to export. Please convert some text first.');
                return;
            }
            
            const tbody = document.getElementById('tableBody');
            const visibleRows = tbody.querySelectorAll('tr:not(.filtered-row):not(.dynamic-row)');
            const filteredData = Array.from(visibleRows).map(row => {
                const index = parseInt(row.getAttribute('data-index'));
                return allData[index];
            });
            
            const dynamicRow = tbody.querySelector('.dynamic-row:not(.filtered-row)');
            if (dynamicRow) {
                const dynamicRecord = createDynamicRow();
                const surveyColumnIndex = tableHeaders.indexOf('Potential Survey');
                if (surveyColumnIndex !== -1) {
                    const surveyCell = dynamicRow.children[surveyColumnIndex];
                    if (surveyCell) {
                        dynamicRecord['Potential Survey'] = surveyCell.textContent;
                    }
                }
                filteredData.push(dynamicRecord);
            }
            
            const formattedJson = JSON.stringify(filteredData, null, 2);
            const blob = new Blob([formattedJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'converted-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showSuccess(`Data exported successfully! (${filteredData.length} records)`);
        }

        function clearAll() {
            document.getElementById('textInput').value = '';
            document.getElementById('channelFilters').style.display = 'none';
            document.getElementById('tableContainer').style.display = 'none';
            document.getElementById('emptyState').style.display = 'flex';
            
            parsedData = [];
            tableHeaders = [];
            activeFilters = {};
            allData = [];
            selectedChannel = 'chat';
            
            document.getElementById('voiceBtn').classList.remove('active');
            document.getElementById('chatBtn').classList.add('active');
            
            updateSurveyAlert('No', false);
        }

        // Load sample data for testing
        window.onload = function() {
            const sampleText = `2025-09-08 14:13

Van Khang Vu

CNX Vietnam
First Line
19: Chat / 43: No response
1. Customer not reached / 1: Chat disconnected

Customer contact name: Philip Lledo Genesys ID: https://apps.mypurecloud.de/directory/#/engage/admin/interactions/99fbb787-c5de-4a4b-839d-bb8f8c5f8e16

2025-09-08 13:48

Vuong Hong Ngoc Pham

CNX Vietnam
First Line
1: Phone In / 7: Baggage
2: Baggage claim / 1: Ask customer to send a claim

Customer contact name: Philip Lledo Genesys ID: https://apps.mypurecloud.de/directory/#/engage/admin/interactions/a1a0b3fb-af39-4a50-ad6b-16d5f452057c

2025-09-08 12:55

Shaheen Lakdawala

Mumbai
First Line
32: FL Baggage/Seat Claim / 7: Baggage
5: Receipt reviewed / 1. No error/No refund

Additional information: ******Working on baggage /Seating Claim *****

2025-09-05 07:19

Parag Thombare

Pune
First Line
17: Frontend finalized / 7: Baggage
2: Baggage claim / 1: Ask customer to send a claim

Removed from queue - As per previous notes pax informed they were offered 2PC checked baggage for the OB.`;
            
            document.getElementById('textInput').value = sampleText;
            updateSurveyAlert('No', false);
        };
    </script>
</body>
</html>
